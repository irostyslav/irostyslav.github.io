<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">








    






<link rel="icon" type="image/ico" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="http://localhost:1313/android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313/apple-touch-icon.png">

<meta name="description" content="What are the communication bottlenecks between us and it?"/>



<title>
    
    Prompt Engineering: Dead? | Rostyslav Ivanitsa
    
</title>

<link rel="canonical" href="http://localhost:1313/posts/dead-prompting/"/>

<meta property="og:url" content="http://localhost:1313/posts/dead-prompting/">
  <meta property="og:site_name" content="Rostyslav Ivanitsa">
  <meta property="og:title" content="Prompt Engineering: Dead?">
  <meta property="og:description" content="What are the communication bottlenecks between us and it?">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-05T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-07-05T00:00:00+00:00">
    <meta property="article:tag" content="Prompting">
    <meta property="article:tag" content="Ai">












<link rel="stylesheet" href="/assets/combined.min.8885fa8e3580e919704685af6311e78718493a6b9a52065d5881ca64917f6e2d.css" media="all">











    




</head>







<body class="auto">

  <div class="content">
    <header>
      

<div class="header">

    

    <h1 class="header-title">
        <a href="http://localhost:1313/">Rostyslav Ivanitsa</a>
    </h1>

    <div class="header-menu">
        

        
        

        <p
            class="small ">
            <a href="/" >
                /home
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/posts" >
                /posts
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/library" >
                /library
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/about" >
                /about
            </a>
        </p>
        
        
    </div>

    

</div>

    </header>

    <main class="main">
      




<div class="breadcrumbs"><a href="/">Home</a><span class="breadcrumbs-separator">/</span><a href="/posts/">Posts</a><span class="breadcrumbs-separator">/</span>
        <a href="/posts/dead-prompting/">Prompt Engineering: Dead?</a></div>


<div  class="autonumber" >
  <article>
    <header class="single-intro-container">
        
        <h1 class="single-title">Prompt Engineering: Dead?</h1>
        <p class="single-summary">Manual prompt engineering is inefficient and dead. The future involves automated prompt optimization using a three-part system: a core LLM application, an LLM-as-a-judge evaluator to measure performance, and an auto-improving agent that researches, generates, and refines prompts. This approach has shown significant performance gains, shifting the focus from manual prompt tweaking to building robust evaluators and agentic systems for continuous, automated LLM improvement</p>
        
        <div class="single-subsummary">
          
          <div>
            
            <p class="single-date">
              <time datetime="2025-07-05T00:00:00&#43;00:00">July 5, 2025</time>
              &nbsp; · &nbsp;4 min read
            </p>
          </div>
        </div>
        
    </header>    
        <div class="single-tags"><span>
                  <a href="http://localhost:1313/tags/prompting/">#Prompting</a>
                </span><span>
                  <a href="http://localhost:1313/tags/ai/">#Ai</a>
                </span>
        </div>
      <aside class="toc">
        <p><strong>Table of contents</strong></p>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#the-limitations-of-manual-prompt-iteration">The Limitations of Manual Prompt Iteration</a></li>
    <li><a href="#the-rise-of-automated-prompt-optimization">The Rise of Automated Prompt Optimization</a>
      <ul>
        <li><a href="#the-core-llm-application">The Core LLM Application</a></li>
        <li><a href="#the-evaluator-the-key-to-progress">The Evaluator: The Key to Progress</a></li>
        <li><a href="#the-auto-improving-agent-the-new-engineer">The Auto-Improving Agent: The New &ldquo;Engineer&rdquo;</a></li>
        <li><a href="#the-shift-from-manual-tweaking-to-system-design">The Shift: From Manual Tweaking to System Design</a></li>
      </ul>
    </li>
    <li><a href="#conclusion-where-to-focus-now">Conclusion: Where to Focus Now</a></li>
  </ul>
</nav>
      </aside>
    
    <div class="single-content">
      <h1 class="heading" id="prompt-engineering-dead-whats-next-and-where-to-focus">
  Prompt Engineering: Dead? What&rsquo;s Next and Where to Focus
  <a class="anchor" href="#prompt-engineering-dead-whats-next-and-where-to-focus">#</a>
</h1>
<p>The phrase &ldquo;prompt engineering is dead&rdquo; might sound extreme, but it reflects a growing sentiment among practitioners working with Large Language Models (LLMs). The argument isn&rsquo;t that prompts are irrelevant, but rather that the manual, iterative process traditionally known as &ldquo;prompt engineering&rdquo; is becoming obsolete, or perhaps, was never truly &ldquo;engineering&rdquo; in the first sense.</p>
<h2 class="heading" id="the-limitations-of-manual-prompt-iteration">
  The Limitations of Manual Prompt Iteration
  <a class="anchor" href="#the-limitations-of-manual-prompt-iteration">#</a>
</h2>
<p>Many who have worked extensively with LLMs know the drill: you craft a prompt, test it, find its shortcomings, tweak it, and repeat. This often feels less like a systematic engineering discipline and more like an art form, or even a continuous negotiation with the model. The goal is simple – to make the LLM behave predictably, answer accurately, and align with specific requirements.</p>
<p>However, this manual iteration process quickly becomes inefficient and unsustainable. Why should human developers spend countless hours refining instructions when the core desire is for the LLM to learn from examples and consistently follow directives? This inherent frustration points towards a need for a more automated, scalable approach.</p>
<h2 class="heading" id="the-rise-of-automated-prompt-optimization">
  The Rise of Automated Prompt Optimization
  <a class="anchor" href="#the-rise-of-automated-prompt-optimization">#</a>
</h2>
<p>The future lies in automating the discovery and refinement of effective prompts. This new paradigm treats prompt optimization as a machine learning problem, leveraging a feedback loop to continuously improve performance. The core components of such an automated system include:</p>
<h3 class="heading" id="the-core-llm-application">
  The Core LLM Application
  <a class="anchor" href="#the-core-llm-application">#</a>
</h3>
<p>At the foundation is your LLM-powered application, often a Retrieval Augmented Generation (RAG) pipeline. This typically involves:</p>
<p>A vector database for retrieving relevant information.</p>
<p>An LLM service for generating responses.</p>
<p>Initial prompts that guide the LLM in processing user queries and retrieved context to produce an answer.</p>
<h3 class="heading" id="the-evaluator-the-key-to-progress">
  The Evaluator: The Key to Progress
  <a class="anchor" href="#the-evaluator-the-key-to-progress">#</a>
</h3>
<p>For any system to improve, it must first be able to measure its performance. An &ldquo;LLM as a judge&rdquo; evaluator is a powerful technique here. This involves:</p>
<ul>
<li>
<p><strong>Creating a Dataset:</strong> A collection of representative questions or scenarios relevant to your application&rsquo;s domain.</p>
</li>
<li>
<p><strong>Defining Ground Truth:</strong> For each question, specifying the expected facts or characteristics the LLM&rsquo;s answer should contain.</p>
</li>
<li>
<p><strong>Scoring Mechanism:</strong> The evaluator takes the LLM&rsquo;s generated answer and assesses it against the predefined ground truth, assigning a score and providing reasons for any discrepancies. This quantifiable score is crucial for driving automated improvement.</p>
</li>
</ul>
<p>This evaluation step transforms subjective prompt quality into an objective, measurable metric.</p>
<h3 class="heading" id="the-auto-improving-agent-the-new-engineer">
  The Auto-Improving Agent: The New &ldquo;Engineer&rdquo;
  <a class="anchor" href="#the-auto-improving-agent-the-new-engineer">#</a>
</h3>
<p>This is where the automation truly takes over. An intelligent agent is designed to systematically optimize the prompts. Its operational loop typically involves:</p>
<ul>
<li>
<p>Baseline Measurement: The agent first uses the evaluator to get an initial performance score for the current prompt.</p>
</li>
<li>
<p>Failure Analysis: It analyzes the reasons for any evaluation failures, identifying areas where the prompt is insufficient or misleading.</p>
</li>
<li>
<p>Knowledge Integration: The agent can access and process information on effective prompting strategies and best practices.</p>
</li>
</ul>
<p>Prompt Generation: Combining the failure analysis with prompting knowledge, the agent generates a new, refined version of the prompt.</p>
<p>Re-evaluation and Iteration: The new prompt is then fed back into the LLM application, and the evaluator runs again to measure the impact. This iterative process allows the agent to continuously &ldquo;learn&rdquo; and converge on optimal prompts.</p>
<h3 class="heading" id="the-shift-from-manual-tweaking-to-system-design">
  The Shift: From Manual Tweaking to System Design
  <a class="anchor" href="#the-shift-from-manual-tweaking-to-system-design">#</a>
</h3>
<p>The results of this automated approach are compelling. Significant improvements in LLM performance can be achieved rapidly, without human intervention in the prompt writing process. Prompts that might take human engineers days or weeks to perfect can be generated and optimized automatically.</p>
<p>This doesn&rsquo;t mean prompts are irrelevant; it means the method of creating and refining them is changing. The focus shifts from the tedious task of manually writing and iterating on prompts to the more strategic work of:</p>
<ul>
<li>
<p>Building Robust Evaluators: Designing comprehensive datasets and effective scoring mechanisms that accurately reflect desired LLM behavior.</p>
</li>
<li>
<p>Developing Intelligent Agents: Creating the automated systems that can analyze performance, research strategies, and generate optimized prompts.</p>
</li>
</ul>
<p>Managing the Optimization Loop: Ensuring the automated process is efficient, avoids overfitting, and generalizes well to new data.</p>
<h2 class="heading" id="conclusion-where-to-focus-now">
  Conclusion: Where to Focus Now
  <a class="anchor" href="#conclusion-where-to-focus-now">#</a>
</h2>
<p>The era of manual prompt engineering, as a primary method of LLM optimization, is indeed giving way to a more sophisticated, automated approach. For those working with LLMs, the path forward is clear: invest your efforts not in endless prompt tweaking, but in building the infrastructure that allows prompts to optimize themselves. Focus on:</p>
<ul>
<li>
<p>Data Quality: High-quality evaluation datasets are paramount.</p>
</li>
<li>
<p>Evaluation Metrics: Develop precise and objective ways to measure LLM output.</p>
</li>
<li>
<p>Agentic Systems: Design and implement intelligent agents capable of iterative prompt refinement.</p>
</li>
</ul>
<p>By embracing automated prompt optimization, we can move beyond the &ldquo;art&rdquo; of prompt engineering and truly embrace an &ldquo;engineering&rdquo; discipline for building powerful, reliable LLM applications.</p>

    </div>
  </article>

  

  

  
  

<div class="single-pagination">
    <hr />

    <div class="flexnowrap">

        <div class="single-pagination-prev">
            
            <div class="single-pagination-container-prev">
                <div class="single-pagination-text">←</div>
                <div class="single-pagination-text">
                    <a href="/posts/prob-queue/">
                        Prompt engineering is dead. 
                    </a>
                </div>
            </div>
            
        </div>

        <div class="single-pagination-next">
            
            <div class="single-pagination-container-next">
                <div class="single-pagination-text">
                    <a href="/posts/pm-ai-agents/">
                        PMs versus AI Agents
                    </a>
                </div>
                <div class="single-pagination-text">→</div>
            </div>
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


    </main>
  </div>

  
  





    




  <footer>
    


    
    





    




    

<footer class="footer"
style="margin-bottom: 50px; margin-top: 0em;">
    <div class="footer__inner">
        <div class="footer__content" style="text-align: center;">

        <span style="text-align: center">
            <a href="mailto:ros@ivanitsa.com">ros@ivanitsa.com</a>
        </span>
            
            <br>
        <span>
            &copy; 2025
        </span>
        </div>
    </div>
</footer>

    
    
    

  </footer>

  
  <link rel="stylesheet" 
  href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css">
  
<script defer 
  src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"></script>

<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body);"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  });
</script>
  
</body>

<script src="/js/theme-switch.js"></script>
<script defer src="/js/copy-code.js"></script>
</html>
